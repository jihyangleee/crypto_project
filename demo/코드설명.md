# 코드 구조 및 주요 기능 설명

## 📂 프로젝트 구조

```
demo/src/main/java/com/example/app/
├── net/                    # 네트워크 통신 계층
│   ├── ChatClient.java     # 클라이언트 연결 및 전송
│   └── ChatServer.java     # 서버 수신 및 처리
├── model/                  # 암호화 유틸리티
│   └── CryptoUtil.java     # RSA, AES 암호화/복호화
├── crypto/                 # 암호화 서비스 인터페이스
│   ├── KeyService.java
│   ├── EncryptService.java
│   └── SignService.java
├── services/mock/          # 실제 구현체
│   ├── RealKeyService.java
│   ├── RealEncryptService.java
│   └── RealSignService.java
├── ui/                     # JavaFX UI 컨트롤러
│   └── MainViewController.java
└── domain/                 # 데이터 모델
    ├── KeyInfo.java
    ├── Packet.java
    └── LogEntry.java
```

---

## 🔐 핵심 암호화 흐름

### 1️⃣ **연결 및 키 교환 (ChatClient.connect / ChatServer.start)**

```
클라이언트                          서버
    |                                |
    |  1) 서버 RSA 공개키 수신       |
    |<-------------------------------|
    |                                |
    |  2) 클라이언트 RSA 공개키 전송 |
    |------------------------------>|
    |                                |
    |  3) AES 세션키 생성             |
    |     서버 공개키로 암호화        |
    |     암호화된 AES 키 전송       |
    |------------------------------>|
    |                                |  4) 서버 개인키로 복호화
    |                                |     AES 세션키 획득
```

**주요 코드 (ChatClient.java):**
```java
// 서버의 RSA 공개키로 AES 세션키를 암호화해서 전송
javax.crypto.SecretKey aes = KeyGenerator.getInstance("AES").generateKey();
byte[] aesRaw = aes.getEncoded();
byte[] encAes = CryptoUtil.rsaEncrypt(peerPublicKey, aesRaw); // RSA로 래핑
```

**주요 코드 (ChatServer.java):**
```java
// 서버의 개인키로 암호화된 AES 세션키를 복호화
byte[] aesRaw = CryptoUtil.rsaDecrypt(kp.getPrivate(), encAes);
SecretKey aesKey = CryptoUtil.aesKeyFromBytes(aesRaw);
```

---

### 2️⃣ **메시지 전송 (암호화 + 서명)**

```
클라이언트 측 (ChatClient.send):
1. 평문 준비: "Hello"
2. 서명 생성: SHA256withRSA(평문) → 256바이트 서명
3. 평문 암호화: AES-GCM(평문) → 암호문
4. 서명 암호화: AES-GCM(서명) → 암호화된 서명
5. 전송:
   - TYPE_CHAT(1): 암호화된 평문
   - TYPE_SIGNATURE(5): 암호화된 서명
```

**주요 코드 (ChatClient.java):**
```java
if (encrypt && sign) {
    // 평문에 서명 생성 (SHA256withRSA)
    byte[] signature = signData(pt);
    
    // 평문 암호화해서 전송
    sendFramed(1, pt);  // TYPE_CHAT
    
    // 서명 암호화해서 전송
    sendFramed(5, signature);  // TYPE_SIGNATURE
}
```

---

### 3️⃣ **메시지 수신 및 검증 (ChatServer)**

```
서버 측:
1. AES 키로 암호문 복호화 → 평문 획득
2. AES 키로 서명 복호화 → 서명 획득
3. 클라이언트 공개키로 서명 검증:
   - 평문의 SHA-256 해시 계산
   - 서명을 공개키로 복호화
   - 두 해시값 비교 → verified true/false
```

**주요 코드 (ChatServer.java):**
```java
// 1. 암호문 복호화
byte[] plain = CryptoUtil.aesDecrypt(aesKey, ct, msgIv);

// 2. 서명 복호화
byte[] signature = CryptoUtil.aesDecrypt(aesKey, ct, msgIv);

// 3. 서명 검증
java.security.Signature sig = Signature.getInstance("SHA256withRSA");
sig.initVerify(clientPub);  // 클라이언트 공개키 사용
sig.update(lastPlaintext);  // 평문 해시 계산
boolean verified = sig.verify(signature);  // 서명 검증
```

---

## 🔧 주요 암호화 알고리즘

### **CryptoUtil.java**

| 메서드 | 알고리즘 | 용도 |
|--------|---------|------|
| `rsaEncrypt()` | RSA-2048 OAEP (SHA-256) | AES 세션키 암호화 |
| `rsaDecrypt()` | RSA-2048 OAEP (SHA-256) | AES 세션키 복호화 |
| `aesEncrypt()` | AES-128-GCM | 메시지/파일 암호화 |
| `aesDecrypt()` | AES-128-GCM | 메시지/파일 복호화 |

### **서명 알고리즘 (ChatClient.signData)**
```java
Signature signer = Signature.getInstance("SHA256withRSA");
signer.initSign(myPrivateKey);  // 내 개인키로 서명
signer.update(data);            // 평문 해시 계산
return signer.sign();           // 서명 생성
```

---

## 📊 전송 모드 (4가지)

| 암호화 | 서명 | 설명 | 메시지 타입 |
|--------|------|------|------------|
| ✅ | ✅ | 암호화 + 서명 (기본값) | TYPE_CHAT(1) + TYPE_SIGNATURE(5) |
| ✅ | ❌ | 암호화만 | TYPE_CHAT(1) |
| ❌ | ✅ | 평문 + 서명 | TYPE_PLAINTEXT_CHAT(7) + TYPE_PLAINTEXT_SIGNATURE(8) |
| ❌ | ❌ | 평문만 | TYPE_PLAINTEXT_CHAT(7) |

---

## 🎯 체크박스 동작 원리

**MainViewController.java:**
```java
// UI 체크박스 읽기
boolean shouldEncrypt = encryptCheck.isSelected();
boolean shouldSign = signCheck.isSelected();

// 전송 시 적용
client.send(text, shouldEncrypt, shouldSign);
client.sendFile(file, shouldEncrypt, shouldSign);
```

---

## 🔍 서버의 서명 검증 대기 로직

문제: 서명 없는 메시지가 두 번 클릭해야 전송되던 이슈  
해결: 50ms 대기 후 다음 데이터 확인

```java
// 메시지 수신 후 서명이 올지 50ms 대기
Thread.sleep(50);

if (in.available() == 0) {
    // 서명 없음 - 즉시 UI에 표시
    onMessageReceived.accept(data);
} else {
    // 서명 대기 중 - 다음 루프에서 처리
}
```

---

## 📁 파일 전송 흐름

1. **메타데이터 전송**: 파일명 + 파일 크기
2. **청크 단위 전송**: 8192바이트씩 분할 전송
3. **서명 전송** (선택): 전체 파일 데이터에 대한 서명
4. **종료 신호**: TYPE_FILE_END

```java
// 암호화 파일 전송
sendFramed(2, meta);           // TYPE_FILE_META
sendFramed(3, chunk);          // TYPE_FILE_CHUNK (반복)
sendFramed(6, signature);      // TYPE_FILE_SIGNATURE (선택)
sendFramed(4, new byte[0]);    // TYPE_FILE_END
```

---

## 🛡️ 보안 특징

1. **하이브리드 암호화**: RSA로 AES 키를 안전하게 전송, AES로 실제 데이터 암호화
2. **인증된 암호화**: AES-GCM 모드로 무결성 자동 검증
3. **디지털 서명**: SHA256withRSA로 발신자 인증 및 변조 방지
4. **매 세션 새 키**: 연결마다 새로운 AES 세션키 생성
5. **선택적 보안**: 사용자가 암호화/서명 여부를 선택 가능

---

## 🚀 실행 방법

```powershell
cd d:\crypto_pro\demo
.\gradlew.bat runSecureUI
```

- 두 개의 창을 띄워 하나는 Server, 하나는 Client로 설정
- Server에서 먼저 Connect → Client에서 Connect
- 연결 후 체크박스로 암호화/서명 옵션 선택하여 메시지/파일 전송

---

## 📝 로그 확인

UI 하단의 Logs 탭에서 모든 암호화 과정을 실시간으로 확인 가능:
- 키 교환 과정
- 암호화/복호화 단계
- 서명 생성 및 검증 결과
- 파일 전송 진행 상황
